"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdateapp"]("LumaView",{

/***/ "./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/LumaView.vue?vue&type=template&id=0881f348&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/LumaView.vue?vue&type=template&id=0881f348&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"staticRenderFns\": function() { return /* binding */ staticRenderFns; }\n/* harmony export */ });\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    [\n      !_vm.first_folder\n        ? _c(\"LoaderSpinner\")\n        : _c(\"div\", { staticClass: \"_multiPanes\" }, [\n            _c(\n              \"section\",\n              { staticClass: \"_myContent\" },\n              [\n                _vm.show_authors_modal\n                  ? _c(\"AuthorList\", {\n                      on: {\n                        close: function ($event) {\n                          _vm.show_authors_modal = false\n                        },\n                      },\n                    })\n                  : _vm._e(),\n                _c(\"div\", { staticClass: \"_subscribeBtn\" }, [\n                  _c(\n                    \"button\",\n                    {\n                      staticClass: \"_authorBtn\",\n                      attrs: { type: \"button\" },\n                      on: { click: _vm.showAuthorModal },\n                    },\n                    [\n                      _vm.connected_as\n                        ? [_vm._v(\" \" + _vm._s(_vm.connected_as.name) + \" \")]\n                        : [_vm._v(_vm._s(_vm.$t(\"login\")))],\n                    ],\n                    2\n                  ),\n                ]),\n                _vm.connected_as\n                  ? _c(\"div\", {}, [_c(\"MyChutier\")], 1)\n                  : _vm._e(),\n              ],\n              1\n            ),\n            _c(\n              \"section\",\n              { staticClass: \"_sharedContent\" },\n              [_c(\"EspaceCommun\")],\n              1\n            ),\n          ]),\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvdmlld3MvTHVtYVZpZXcudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTA4ODFmMzQ4JnNjb3BlZD10cnVlJi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9zcmMvdmlld3MvTHVtYVZpZXcudnVlP2U1NjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICBbXG4gICAgICAhX3ZtLmZpcnN0X2ZvbGRlclxuICAgICAgICA/IF9jKFwiTG9hZGVyU3Bpbm5lclwiKVxuICAgICAgICA6IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiX211bHRpUGFuZXNcIiB9LCBbXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJzZWN0aW9uXCIsXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiX215Q29udGVudFwiIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uc2hvd19hdXRob3JzX21vZGFsXG4gICAgICAgICAgICAgICAgICA/IF9jKFwiQXV0aG9yTGlzdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5zaG93X2F1dGhvcnNfbW9kYWwgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIl9zdWJzY3JpYmVCdG5cIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIl9hdXRob3JCdG5cIixcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5zaG93QXV0aG9yTW9kYWwgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5jb25uZWN0ZWRfYXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW192bS5fdihcIiBcIiArIF92bS5fcyhfdm0uY29ubmVjdGVkX2FzLm5hbWUpICsgXCIgXCIpXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbX3ZtLl92KF92bS5fcyhfdm0uJHQoXCJsb2dpblwiKSkpXSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfdm0uY29ubmVjdGVkX2FzXG4gICAgICAgICAgICAgICAgICA/IF9jKFwiZGl2XCIsIHt9LCBbX2MoXCJNeUNodXRpZXJcIildLCAxKVxuICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcInNlY3Rpb25cIixcbiAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJfc2hhcmVkQ29udGVudFwiIH0sXG4gICAgICAgICAgICAgIFtfYyhcIkVzcGFjZUNvbW11blwiKV0sXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSksXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/LumaView.vue?vue&type=template&id=0881f348&scoped=true&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/LumaView.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/LumaView.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var splitpanes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! splitpanes */ \"./node_modules/splitpanes/dist/splitpanes.es.js\");\n/* harmony import */ var _adc_core_author_AuthorList_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/adc-core/author/AuthorList.vue */ \"./src/adc-core/author/AuthorList.vue\");\n/* harmony import */ var _components_MyChutier_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/MyChutier.vue */ \"./src/components/MyChutier.vue\");\n/* harmony import */ var _components_EspaceCommun_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/EspaceCommun.vue */ \"./src/components/EspaceCommun.vue\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {},\n  components: {\n    AuthorList: _adc_core_author_AuthorList_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    MyChutier: _components_MyChutier_vue__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    EspaceCommun: _components_EspaceCommun_vue__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    Splitpanes: splitpanes__WEBPACK_IMPORTED_MODULE_0__.Splitpanes,\n    Pane: splitpanes__WEBPACK_IMPORTED_MODULE_0__.Pane\n  },\n  data() {\n    return {\n      path: \"folders\",\n      folders: undefined,\n      show_authors_modal: false\n    };\n  },\n  created() {},\n  async mounted() {\n    await this.loadFolder();\n    // check if necerray to login or create account :\n    if (!this.connected_as) this.showAuthorModal();\n  },\n  beforeDestroy() {},\n  watch: {\n    connected_as() {\n      // if (this.connected_as) {\n      // this.show_authors_modal = false;\n      // }\n    }\n  },\n  computed: {\n    first_folder() {\n      if (this.folders && this.folders.length > 0) return this.folders[0];\n      return false;\n    }\n  },\n  methods: {\n    async loadFolder() {\n      this.folders = await this.$api.getFolders({\n        path: this.path\n      }).catch(err => {\n        this.fetch_spaces_error = err.response;\n        // this.is_loading = false;\n        return;\n      });\n      if (this.folders.length === 0) {\n        await this.createFolder();\n        window.location.reload();\n      }\n      this.$api.join({\n        room: this.path\n      });\n    },\n    async createFolder() {\n      try {\n        const new_space_slug = await this.$api.createFolder({\n          path: this.path\n        });\n        return new_space_slug;\n      } catch (err) {\n        // this.error_msg = \"Error: \" + err.message;\n        // setTimeout(() => {\n        //   this.error_msg = \"\";\n        // }, 5000);\n        // this.is_creating_project = false;\n      }\n    },\n    showAuthorModal() {\n      this.show_authors_modal = true;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0zN1swXS5ydWxlc1swXS51c2VbMF0hLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy92aWV3cy9MdW1hVmlldy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwL3NyYy92aWV3cy9MdW1hVmlldy52dWU/NzA3NSJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPCEtLSAvLyBpZGVudGlmaWV6LXZvdXMgIC0tPlxuICAgIDwhLS0gLy8gdW5lIGZvaXMgaWRlbnRpZmnDqSwgYWNjw6hzIMOgIHNvbiBjaHV0aWVyIC0tPlxuICAgIDwhLS0gLy8gKyBhY2PDqHMgYXUgbG90IGNvbW11biAtLT5cbiAgICA8TG9hZGVyU3Bpbm5lciB2LWlmPVwiIWZpcnN0X2ZvbGRlclwiIC8+XG4gICAgPGRpdiB2LWVsc2UgY2xhc3M9XCJfbXVsdGlQYW5lc1wiPlxuICAgICAgPHNlY3Rpb24gY2xhc3M9XCJfbXlDb250ZW50XCI+XG4gICAgICAgIDxBdXRob3JMaXN0XG4gICAgICAgICAgdi1pZj1cInNob3dfYXV0aG9yc19tb2RhbFwiXG4gICAgICAgICAgQGNsb3NlPVwic2hvd19hdXRob3JzX21vZGFsID0gZmFsc2VcIlxuICAgICAgICAvPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJfc3Vic2NyaWJlQnRuXCI+XG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJfYXV0aG9yQnRuXCIgQGNsaWNrPVwic2hvd0F1dGhvck1vZGFsXCI+XG4gICAgICAgICAgICA8dGVtcGxhdGUgdi1pZj1cImNvbm5lY3RlZF9hc1wiPlxuICAgICAgICAgICAgICB7eyBjb25uZWN0ZWRfYXMubmFtZSB9fVxuICAgICAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+e3sgJHQoXCJsb2dpblwiKSB9fTwvdGVtcGxhdGU+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgdi1pZj1cImNvbm5lY3RlZF9hc1wiIGNsYXNzPVwiXCI+XG4gICAgICAgICAgPE15Q2h1dGllciAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICAgIDxzZWN0aW9uIGNsYXNzPVwiX3NoYXJlZENvbnRlbnRcIj5cbiAgICAgICAgPEVzcGFjZUNvbW11biAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuaW1wb3J0IHsgU3BsaXRwYW5lcywgUGFuZSB9IGZyb20gXCJzcGxpdHBhbmVzXCI7XG5cbmltcG9ydCBBdXRob3JMaXN0IGZyb20gXCJAL2FkYy1jb3JlL2F1dGhvci9BdXRob3JMaXN0LnZ1ZVwiO1xuaW1wb3J0IE15Q2h1dGllciBmcm9tIFwiQC9jb21wb25lbnRzL015Q2h1dGllci52dWVcIjtcbmltcG9ydCBFc3BhY2VDb21tdW4gZnJvbSBcIkAvY29tcG9uZW50cy9Fc3BhY2VDb21tdW4udnVlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHt9LFxuICBjb21wb25lbnRzOiB7XG4gICAgQXV0aG9yTGlzdCxcbiAgICBNeUNodXRpZXIsXG4gICAgRXNwYWNlQ29tbXVuLFxuICAgIFNwbGl0cGFuZXMsXG4gICAgUGFuZSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogXCJmb2xkZXJzXCIsXG4gICAgICBmb2xkZXJzOiB1bmRlZmluZWQsXG4gICAgICBzaG93X2F1dGhvcnNfbW9kYWw6IGZhbHNlLFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZWQoKSB7fSxcbiAgYXN5bmMgbW91bnRlZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRGb2xkZXIoKTtcbiAgICAvLyBjaGVjayBpZiBuZWNlcnJheSB0byBsb2dpbiBvciBjcmVhdGUgYWNjb3VudCA6XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZF9hcykgdGhpcy5zaG93QXV0aG9yTW9kYWwoKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHt9LFxuICB3YXRjaDoge1xuICAgIGNvbm5lY3RlZF9hcygpIHtcbiAgICAgIC8vIGlmICh0aGlzLmNvbm5lY3RlZF9hcykge1xuICAgICAgLy8gdGhpcy5zaG93X2F1dGhvcnNfbW9kYWwgPSBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICB9LFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGZpcnN0X2ZvbGRlcigpIHtcbiAgICAgIGlmICh0aGlzLmZvbGRlcnMgJiYgdGhpcy5mb2xkZXJzLmxlbmd0aCA+IDApIHJldHVybiB0aGlzLmZvbGRlcnNbMF07XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGFzeW5jIGxvYWRGb2xkZXIoKSB7XG4gICAgICB0aGlzLmZvbGRlcnMgPSBhd2FpdCB0aGlzLiRhcGlcbiAgICAgICAgLmdldEZvbGRlcnMoe1xuICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aGlzLmZldGNoX3NwYWNlc19lcnJvciA9IGVyci5yZXNwb25zZTtcbiAgICAgICAgICAvLyB0aGlzLmlzX2xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuZm9sZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVGb2xkZXIoKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRhcGkuam9pbih7IHJvb206IHRoaXMucGF0aCB9KTtcbiAgICB9LFxuICAgIGFzeW5jIGNyZWF0ZUZvbGRlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld19zcGFjZV9zbHVnID0gYXdhaXQgdGhpcy4kYXBpLmNyZWF0ZUZvbGRlcih7XG4gICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld19zcGFjZV9zbHVnO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoaXMuZXJyb3JfbXNnID0gXCJFcnJvcjogXCIgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vICAgdGhpcy5lcnJvcl9tc2cgPSBcIlwiO1xuICAgICAgICAvLyB9LCA1MDAwKTtcbiAgICAgICAgLy8gdGhpcy5pc19jcmVhdGluZ19wcm9qZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93QXV0aG9yTW9kYWwoKSB7XG4gICAgICB0aGlzLnNob3dfYXV0aG9yc19tb2RhbCA9IHRydWU7XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbi5fbXlDb250ZW50IHtcbiAgd2lkdGg6IDU1MHB4O1xuICBtaW4taGVpZ2h0OiA1NTBweDtcbiAgaGVpZ2h0OiAxMDAlO1xuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgYm94LXNoYWRvdzogMCAwcHggNXB4IHJnYigwIDAgMCAvIDEyJSk7XG59XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/views/LumaView.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/splitpanes/dist/splitpanes.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/splitpanes/dist/splitpanes.es.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pane\": function() { return /* binding */ pane; },\n/* harmony export */   \"Splitpanes\": function() { return /* binding */ splitpanes; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"./node_modules/core-js/modules/es.array.reduce.js\");\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.includes.js */ \"./node_modules/core-js/modules/es.array.includes.js\");\n/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar splitpanes_vue_vue_type_style_index_0_lang = \"\";\nfunction normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {\n  var options = typeof scriptExports === \"function\" ? scriptExports.options : scriptExports;\n  if (render2) {\n    options.render = render2;\n    options.staticRenderFns = staticRenderFns2;\n    options._compiled = true;\n  }\n  if (functionalTemplate) {\n    options.functional = true;\n  }\n  if (scopeId) {\n    options._scopeId = \"data-v-\" + scopeId;\n  }\n  var hook;\n  if (moduleIdentifier) {\n    hook = function (context) {\n      context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== \"undefined\") {\n        context = __VUE_SSR_CONTEXT__;\n      }\n      if (injectStyles) {\n        injectStyles.call(this, context);\n      }\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    };\n    options._ssrRegister = hook;\n  } else if (injectStyles) {\n    hook = shadowMode ? function () {\n      injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);\n    } : injectStyles;\n  }\n  if (hook) {\n    if (options.functional) {\n      options._injectStyles = hook;\n      var originalRender = options.render;\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      var existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n  return {\n    exports: scriptExports,\n    options\n  };\n}\nconst __vue2_script$1 = {\n  name: \"splitpanes\",\n  props: {\n    horizontal: {\n      type: Boolean\n    },\n    pushOtherPanes: {\n      type: Boolean,\n      default: true\n    },\n    dblClickSplitter: {\n      type: Boolean,\n      default: true\n    },\n    rtl: {\n      type: Boolean,\n      default: false\n    },\n    firstSplitter: {\n      type: Boolean\n    }\n  },\n  provide() {\n    return {\n      requestUpdate: this.requestUpdate,\n      onPaneAdd: this.onPaneAdd,\n      onPaneRemove: this.onPaneRemove,\n      onPaneClick: this.onPaneClick\n    };\n  },\n  data: () => ({\n    container: null,\n    ready: false,\n    panes: [],\n    touch: {\n      mouseDown: false,\n      dragging: false,\n      activeSplitter: null\n    },\n    splitterTaps: {\n      splitter: null,\n      timeoutId: null\n    }\n  }),\n  computed: {\n    panesCount() {\n      return this.panes.length;\n    },\n    indexedPanes() {\n      return this.panes.reduce((obj, pane2) => (obj[pane2.id] = pane2) && obj, {});\n    }\n  },\n  methods: {\n    updatePaneComponents() {\n      this.panes.forEach(pane2 => {\n        pane2.update && pane2.update({\n          [this.horizontal ? \"height\" : \"width\"]: `${this.indexedPanes[pane2.id].size}%`\n        });\n      });\n    },\n    bindEvents() {\n      document.addEventListener(\"mousemove\", this.onMouseMove, {\n        passive: false\n      });\n      document.addEventListener(\"mouseup\", this.onMouseUp);\n      if (\"ontouchstart\" in window) {\n        document.addEventListener(\"touchmove\", this.onMouseMove, {\n          passive: false\n        });\n        document.addEventListener(\"touchend\", this.onMouseUp);\n      }\n    },\n    unbindEvents() {\n      document.removeEventListener(\"mousemove\", this.onMouseMove, {\n        passive: false\n      });\n      document.removeEventListener(\"mouseup\", this.onMouseUp);\n      if (\"ontouchstart\" in window) {\n        document.removeEventListener(\"touchmove\", this.onMouseMove, {\n          passive: false\n        });\n        document.removeEventListener(\"touchend\", this.onMouseUp);\n      }\n    },\n    onMouseDown(event, splitterIndex) {\n      this.bindEvents();\n      this.touch.mouseDown = true;\n      this.touch.activeSplitter = splitterIndex;\n    },\n    onMouseMove(event) {\n      if (this.touch.mouseDown) {\n        event.preventDefault();\n        this.touch.dragging = true;\n        this.calculatePanesSize(this.getCurrentMouseDrag(event));\n        this.$emit(\"resize\", this.panes.map(pane2 => ({\n          min: pane2.min,\n          max: pane2.max,\n          size: pane2.size\n        })));\n      }\n    },\n    onMouseUp() {\n      if (this.touch.dragging) {\n        this.$emit(\"resized\", this.panes.map(pane2 => ({\n          min: pane2.min,\n          max: pane2.max,\n          size: pane2.size\n        })));\n      }\n      this.touch.mouseDown = false;\n      setTimeout(() => {\n        this.touch.dragging = false;\n        this.unbindEvents();\n      }, 100);\n    },\n    onSplitterClick(event, splitterIndex) {\n      if (\"ontouchstart\" in window) {\n        event.preventDefault();\n        if (this.dblClickSplitter) {\n          if (this.splitterTaps.splitter === splitterIndex) {\n            clearTimeout(this.splitterTaps.timeoutId);\n            this.splitterTaps.timeoutId = null;\n            this.onSplitterDblClick(event, splitterIndex);\n            this.splitterTaps.splitter = null;\n          } else {\n            this.splitterTaps.splitter = splitterIndex;\n            this.splitterTaps.timeoutId = setTimeout(() => {\n              this.splitterTaps.splitter = null;\n            }, 500);\n          }\n        }\n      }\n      if (!this.touch.dragging) this.$emit(\"splitter-click\", this.panes[splitterIndex]);\n    },\n    onSplitterDblClick(event, splitterIndex) {\n      let totalMinSizes = 0;\n      this.panes = this.panes.map((pane2, i) => {\n        pane2.size = i === splitterIndex ? pane2.max : pane2.min;\n        if (i !== splitterIndex) totalMinSizes += pane2.min;\n        return pane2;\n      });\n      this.panes[splitterIndex].size -= totalMinSizes;\n      this.$emit(\"pane-maximize\", this.panes[splitterIndex]);\n    },\n    onPaneClick(event, paneId) {\n      this.$emit(\"pane-click\", this.indexedPanes[paneId]);\n    },\n    getCurrentMouseDrag(event) {\n      const rect = this.container.getBoundingClientRect();\n      const {\n        clientX,\n        clientY\n      } = \"ontouchstart\" in window && event.touches ? event.touches[0] : event;\n      return {\n        x: clientX - rect.left,\n        y: clientY - rect.top\n      };\n    },\n    getCurrentDragPercentage(drag) {\n      drag = drag[this.horizontal ? \"y\" : \"x\"];\n      const containerSize = this.container[this.horizontal ? \"clientHeight\" : \"clientWidth\"];\n      if (this.rtl && !this.horizontal) drag = containerSize - drag;\n      return drag * 100 / containerSize;\n    },\n    calculatePanesSize(drag) {\n      const splitterIndex = this.touch.activeSplitter;\n      let sums = {\n        prevPanesSize: this.sumPrevPanesSize(splitterIndex),\n        nextPanesSize: this.sumNextPanesSize(splitterIndex),\n        prevReachedMinPanes: 0,\n        nextReachedMinPanes: 0\n      };\n      const minDrag = 0 + (this.pushOtherPanes ? 0 : sums.prevPanesSize);\n      const maxDrag = 100 - (this.pushOtherPanes ? 0 : sums.nextPanesSize);\n      const dragPercentage = Math.max(Math.min(this.getCurrentDragPercentage(drag), maxDrag), minDrag);\n      let panesToResize = [splitterIndex, splitterIndex + 1];\n      let paneBefore = this.panes[panesToResize[0]] || null;\n      let paneAfter = this.panes[panesToResize[1]] || null;\n      const paneBeforeMaxReached = paneBefore.max < 100 && dragPercentage >= paneBefore.max + sums.prevPanesSize;\n      const paneAfterMaxReached = paneAfter.max < 100 && dragPercentage <= 100 - (paneAfter.max + this.sumNextPanesSize(splitterIndex + 1));\n      if (paneBeforeMaxReached || paneAfterMaxReached) {\n        if (paneBeforeMaxReached) {\n          paneBefore.size = paneBefore.max;\n          paneAfter.size = Math.max(100 - paneBefore.max - sums.prevPanesSize - sums.nextPanesSize, 0);\n        } else {\n          paneBefore.size = Math.max(100 - paneAfter.max - sums.prevPanesSize - this.sumNextPanesSize(splitterIndex + 1), 0);\n          paneAfter.size = paneAfter.max;\n        }\n        return;\n      }\n      if (this.pushOtherPanes) {\n        const vars = this.doPushOtherPanes(sums, dragPercentage);\n        if (!vars) return;\n        ({\n          sums,\n          panesToResize\n        } = vars);\n        paneBefore = this.panes[panesToResize[0]] || null;\n        paneAfter = this.panes[panesToResize[1]] || null;\n      }\n      if (paneBefore !== null) {\n        paneBefore.size = Math.min(Math.max(dragPercentage - sums.prevPanesSize - sums.prevReachedMinPanes, paneBefore.min), paneBefore.max);\n      }\n      if (paneAfter !== null) {\n        paneAfter.size = Math.min(Math.max(100 - dragPercentage - sums.nextPanesSize - sums.nextReachedMinPanes, paneAfter.min), paneAfter.max);\n      }\n    },\n    doPushOtherPanes(sums, dragPercentage) {\n      const splitterIndex = this.touch.activeSplitter;\n      const panesToResize = [splitterIndex, splitterIndex + 1];\n      if (dragPercentage < sums.prevPanesSize + this.panes[panesToResize[0]].min) {\n        panesToResize[0] = this.findPrevExpandedPane(splitterIndex).index;\n        sums.prevReachedMinPanes = 0;\n        if (panesToResize[0] < splitterIndex) {\n          this.panes.forEach((pane2, i) => {\n            if (i > panesToResize[0] && i <= splitterIndex) {\n              pane2.size = pane2.min;\n              sums.prevReachedMinPanes += pane2.min;\n            }\n          });\n        }\n        sums.prevPanesSize = this.sumPrevPanesSize(panesToResize[0]);\n        if (panesToResize[0] === void 0) {\n          sums.prevReachedMinPanes = 0;\n          this.panes[0].size = this.panes[0].min;\n          this.panes.forEach((pane2, i) => {\n            if (i > 0 && i <= splitterIndex) {\n              pane2.size = pane2.min;\n              sums.prevReachedMinPanes += pane2.min;\n            }\n          });\n          this.panes[panesToResize[1]].size = 100 - sums.prevReachedMinPanes - this.panes[0].min - sums.prevPanesSize - sums.nextPanesSize;\n          return null;\n        }\n      }\n      if (dragPercentage > 100 - sums.nextPanesSize - this.panes[panesToResize[1]].min) {\n        panesToResize[1] = this.findNextExpandedPane(splitterIndex).index;\n        sums.nextReachedMinPanes = 0;\n        if (panesToResize[1] > splitterIndex + 1) {\n          this.panes.forEach((pane2, i) => {\n            if (i > splitterIndex && i < panesToResize[1]) {\n              pane2.size = pane2.min;\n              sums.nextReachedMinPanes += pane2.min;\n            }\n          });\n        }\n        sums.nextPanesSize = this.sumNextPanesSize(panesToResize[1] - 1);\n        if (panesToResize[1] === void 0) {\n          sums.nextReachedMinPanes = 0;\n          this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min;\n          this.panes.forEach((pane2, i) => {\n            if (i < this.panesCount - 1 && i >= splitterIndex + 1) {\n              pane2.size = pane2.min;\n              sums.nextReachedMinPanes += pane2.min;\n            }\n          });\n          this.panes[panesToResize[0]].size = 100 - sums.prevPanesSize - sums.nextReachedMinPanes - this.panes[this.panesCount - 1].min - sums.nextPanesSize;\n          return null;\n        }\n      }\n      return {\n        sums,\n        panesToResize\n      };\n    },\n    sumPrevPanesSize(splitterIndex) {\n      return this.panes.reduce((total, pane2, i) => total + (i < splitterIndex ? pane2.size : 0), 0);\n    },\n    sumNextPanesSize(splitterIndex) {\n      return this.panes.reduce((total, pane2, i) => total + (i > splitterIndex + 1 ? pane2.size : 0), 0);\n    },\n    findPrevExpandedPane(splitterIndex) {\n      const pane2 = [...this.panes].reverse().find(p => p.index < splitterIndex && p.size > p.min);\n      return pane2 || {};\n    },\n    findNextExpandedPane(splitterIndex) {\n      const pane2 = this.panes.find(p => p.index > splitterIndex + 1 && p.size > p.min);\n      return pane2 || {};\n    },\n    checkSplitpanesNodes() {\n      const children = Array.from(this.container.children);\n      children.forEach(child => {\n        const isPane = child.classList.contains(\"splitpanes__pane\");\n        const isSplitter = child.classList.contains(\"splitpanes__splitter\");\n        if (!isPane && !isSplitter) {\n          child.parentNode.removeChild(child);\n          console.warn(\"Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.\");\n          return;\n        }\n      });\n    },\n    addSplitter(paneIndex, nextPaneNode, isVeryFirst = false) {\n      const splitterIndex = paneIndex - 1;\n      const elm = document.createElement(\"div\");\n      elm.classList.add(\"splitpanes__splitter\");\n      if (!isVeryFirst) {\n        elm.onmousedown = event => this.onMouseDown(event, splitterIndex);\n        if (typeof window !== \"undefined\" && \"ontouchstart\" in window) {\n          elm.ontouchstart = event => this.onMouseDown(event, splitterIndex);\n        }\n        elm.onclick = event => this.onSplitterClick(event, splitterIndex + 1);\n      }\n      if (this.dblClickSplitter) {\n        elm.ondblclick = event => this.onSplitterDblClick(event, splitterIndex + 1);\n      }\n      nextPaneNode.parentNode.insertBefore(elm, nextPaneNode);\n    },\n    removeSplitter(node) {\n      node.onmousedown = void 0;\n      node.onclick = void 0;\n      node.ondblclick = void 0;\n      node.parentNode.removeChild(node);\n    },\n    redoSplitters() {\n      const children = Array.from(this.container.children);\n      children.forEach(el => {\n        if (el.className.includes(\"splitpanes__splitter\")) this.removeSplitter(el);\n      });\n      let paneIndex = 0;\n      children.forEach(el => {\n        if (el.className.includes(\"splitpanes__pane\")) {\n          if (!paneIndex && this.firstSplitter) this.addSplitter(paneIndex, el, true);else if (paneIndex) this.addSplitter(paneIndex, el);\n          paneIndex++;\n        }\n      });\n    },\n    requestUpdate(_a) {\n      var _b = _a,\n        {\n          target\n        } = _b,\n        args = __objRest(_b, [\"target\"]);\n      const pane2 = this.indexedPanes[target._uid];\n      Object.entries(args).forEach(([key, value]) => pane2[key] = value);\n    },\n    onPaneAdd(pane2) {\n      let index = -1;\n      Array.from(pane2.$el.parentNode.children).some(el => {\n        if (el.className.includes(\"splitpanes__pane\")) index++;\n        return el === pane2.$el;\n      });\n      const min = parseFloat(pane2.minSize);\n      const max = parseFloat(pane2.maxSize);\n      this.panes.splice(index, 0, {\n        id: pane2._uid,\n        index,\n        min: isNaN(min) ? 0 : min,\n        max: isNaN(max) ? 100 : max,\n        size: pane2.size === null ? null : parseFloat(pane2.size),\n        givenSize: pane2.size,\n        update: pane2.update\n      });\n      this.panes.forEach((p, i) => p.index = i);\n      if (this.ready) {\n        this.$nextTick(() => {\n          this.redoSplitters();\n          this.resetPaneSizes({\n            addedPane: this.panes[index]\n          });\n          this.$emit(\"pane-add\", {\n            index,\n            panes: this.panes.map(pane3 => ({\n              min: pane3.min,\n              max: pane3.max,\n              size: pane3.size\n            }))\n          });\n        });\n      }\n    },\n    onPaneRemove(pane2) {\n      const index = this.panes.findIndex(p => p.id === pane2._uid);\n      const removed = this.panes.splice(index, 1)[0];\n      this.panes.forEach((p, i) => p.index = i);\n      this.$nextTick(() => {\n        this.redoSplitters();\n        this.resetPaneSizes({\n          removedPane: __spreadProps(__spreadValues({}, removed), {\n            index\n          })\n        });\n        this.$emit(\"pane-remove\", {\n          removed,\n          panes: this.panes.map(pane3 => ({\n            min: pane3.min,\n            max: pane3.max,\n            size: pane3.size\n          }))\n        });\n      });\n    },\n    resetPaneSizes(changedPanes = {}) {\n      if (!changedPanes.addedPane && !changedPanes.removedPane) this.initialPanesSizing();else if (this.panes.some(pane2 => pane2.givenSize !== null || pane2.min || pane2.max < 100)) this.equalizeAfterAddOrRemove(changedPanes);else this.equalize();\n      if (this.ready) this.$emit(\"resized\", this.panes.map(pane2 => ({\n        min: pane2.min,\n        max: pane2.max,\n        size: pane2.size\n      })));\n    },\n    equalize() {\n      const equalSpace = 100 / this.panesCount;\n      let leftToAllocate = 0;\n      let ungrowable = [];\n      let unshrinkable = [];\n      this.panes.forEach(pane2 => {\n        pane2.size = Math.max(Math.min(equalSpace, pane2.max), pane2.min);\n        leftToAllocate -= pane2.size;\n        if (pane2.size >= pane2.max) ungrowable.push(pane2.id);\n        if (pane2.size <= pane2.min) unshrinkable.push(pane2.id);\n      });\n      if (leftToAllocate > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable);\n    },\n    initialPanesSizing() {\n      100 / this.panesCount;\n      let leftToAllocate = 100;\n      let ungrowable = [];\n      let unshrinkable = [];\n      let definedSizes = 0;\n      this.panes.forEach(pane2 => {\n        leftToAllocate -= pane2.size;\n        if (pane2.size !== null) definedSizes++;\n        if (pane2.size >= pane2.max) ungrowable.push(pane2.id);\n        if (pane2.size <= pane2.min) unshrinkable.push(pane2.id);\n      });\n      let leftToAllocate2 = 100;\n      if (leftToAllocate > 0.1) {\n        this.panes.forEach(pane2 => {\n          if (pane2.size === null) {\n            pane2.size = Math.max(Math.min(leftToAllocate / (this.panesCount - definedSizes), pane2.max), pane2.min);\n          }\n          leftToAllocate2 -= pane2.size;\n        });\n        if (leftToAllocate2 > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable);\n      }\n    },\n    equalizeAfterAddOrRemove({\n      addedPane,\n      removedPane\n    } = {}) {\n      let equalSpace = 100 / this.panesCount;\n      let leftToAllocate = 0;\n      let ungrowable = [];\n      let unshrinkable = [];\n      if (addedPane && addedPane.givenSize !== null) {\n        equalSpace = (100 - addedPane.givenSize) / (this.panesCount - 1);\n      }\n      this.panes.forEach(pane2 => {\n        leftToAllocate -= pane2.size;\n        if (pane2.size >= pane2.max) ungrowable.push(pane2.id);\n        if (pane2.size <= pane2.min) unshrinkable.push(pane2.id);\n      });\n      if (Math.abs(leftToAllocate) < 0.1) return;\n      this.panes.forEach(pane2 => {\n        if (addedPane && addedPane.givenSize !== null && addedPane.id === pane2.id) ;else pane2.size = Math.max(Math.min(equalSpace, pane2.max), pane2.min);\n        leftToAllocate -= pane2.size;\n        if (pane2.size >= pane2.max) ungrowable.push(pane2.id);\n        if (pane2.size <= pane2.min) unshrinkable.push(pane2.id);\n      });\n      if (leftToAllocate > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable);\n    },\n    readjustSizes(leftToAllocate, ungrowable, unshrinkable) {\n      let equalSpaceToAllocate;\n      if (leftToAllocate > 0) equalSpaceToAllocate = leftToAllocate / (this.panesCount - ungrowable.length);else equalSpaceToAllocate = leftToAllocate / (this.panesCount - unshrinkable.length);\n      this.panes.forEach((pane2, i) => {\n        if (leftToAllocate > 0 && !ungrowable.includes(pane2.id)) {\n          const newPaneSize = Math.max(Math.min(pane2.size + equalSpaceToAllocate, pane2.max), pane2.min);\n          const allocated = newPaneSize - pane2.size;\n          leftToAllocate -= allocated;\n          pane2.size = newPaneSize;\n        } else if (!unshrinkable.includes(pane2.id)) {\n          const newPaneSize = Math.max(Math.min(pane2.size + equalSpaceToAllocate, pane2.max), pane2.min);\n          const allocated = newPaneSize - pane2.size;\n          leftToAllocate -= allocated;\n          pane2.size = newPaneSize;\n        }\n        pane2.update({\n          [this.horizontal ? \"height\" : \"width\"]: `${this.indexedPanes[pane2.id].size}%`\n        });\n      });\n      if (Math.abs(leftToAllocate) > 0.1) {\n        this.$nextTick(() => {\n          if (this.ready) {\n            console.warn(\"Splitpanes: Could not resize panes correctly due to their constraints.\");\n          }\n        });\n      }\n    }\n  },\n  watch: {\n    panes: {\n      deep: true,\n      immediate: false,\n      handler() {\n        this.updatePaneComponents();\n      }\n    },\n    horizontal() {\n      this.updatePaneComponents();\n    },\n    firstSplitter() {\n      this.redoSplitters();\n    },\n    dblClickSplitter(enable) {\n      const splitters = [...this.container.querySelectorAll(\".splitpanes__splitter\")];\n      splitters.forEach((splitter, i) => {\n        splitter.ondblclick = enable ? event => this.onSplitterDblClick(event, i) : void 0;\n      });\n    }\n  },\n  beforeDestroy() {\n    this.ready = false;\n  },\n  mounted() {\n    this.container = this.$refs.container;\n    this.checkSplitpanesNodes();\n    this.redoSplitters();\n    this.resetPaneSizes();\n    this.$emit(\"ready\");\n    this.ready = true;\n  },\n  render(h) {\n    return h(\"div\", {\n      ref: \"container\",\n      class: [\"splitpanes\", `splitpanes--${this.horizontal ? \"horizontal\" : \"vertical\"}`, {\n        \"splitpanes--dragging\": this.touch.dragging\n      }]\n    }, this.$slots.default);\n  }\n};\nlet __vue2_render, __vue2_staticRenderFns;\nconst __cssModules$1 = {};\nvar __component__$1 = /* @__PURE__ */normalizeComponent(__vue2_script$1, __vue2_render, __vue2_staticRenderFns, false, __vue2_injectStyles$1, null, null, null);\nfunction __vue2_injectStyles$1(context) {\n  for (let o in __cssModules$1) {\n    this[o] = __cssModules$1[o];\n  }\n}\nvar splitpanes = /* @__PURE__ */function () {\n  return __component__$1.exports;\n}();\nvar render = function () {\n  var _vm = this;\n  var _h = _vm.$createElement;\n  var _c = _vm._self._c || _h;\n  return _c(\"div\", {\n    staticClass: \"splitpanes__pane\",\n    style: _vm.style,\n    on: {\n      \"click\": function ($event) {\n        return _vm.onPaneClick($event, _vm._uid);\n      }\n    }\n  }, [_vm._t(\"default\")], 2);\n};\nvar staticRenderFns = [];\nconst __vue2_script = {\n  name: \"pane\",\n  inject: [\"requestUpdate\", \"onPaneAdd\", \"onPaneRemove\", \"onPaneClick\"],\n  props: {\n    size: {\n      type: [Number, String],\n      default: null\n    },\n    minSize: {\n      type: [Number, String],\n      default: 0\n    },\n    maxSize: {\n      type: [Number, String],\n      default: 100\n    }\n  },\n  data: () => ({\n    style: {}\n  }),\n  mounted() {\n    this.onPaneAdd(this);\n  },\n  beforeDestroy() {\n    this.onPaneRemove(this);\n  },\n  methods: {\n    update(style) {\n      this.style = style;\n    }\n  },\n  computed: {\n    sizeNumber() {\n      return this.size || this.size === 0 ? parseFloat(this.size) : null;\n    },\n    minSizeNumber() {\n      return parseFloat(this.minSize);\n    },\n    maxSizeNumber() {\n      return parseFloat(this.maxSize);\n    }\n  },\n  watch: {\n    sizeNumber(size) {\n      this.requestUpdate({\n        target: this,\n        size\n      });\n    },\n    minSizeNumber(min) {\n      this.requestUpdate({\n        target: this,\n        min\n      });\n    },\n    maxSizeNumber(max) {\n      this.requestUpdate({\n        target: this,\n        max\n      });\n    }\n  }\n};\nconst __cssModules = {};\nvar __component__ = /* @__PURE__ */normalizeComponent(__vue2_script, render, staticRenderFns, false, __vue2_injectStyles, null, null, null);\nfunction __vue2_injectStyles(context) {\n  for (let o in __cssModules) {\n    this[o] = __cssModules[o];\n  }\n}\nvar pane = /* @__PURE__ */function () {\n  return __component__.exports;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3BsaXRwYW5lcy9kaXN0L3NwbGl0cGFuZXMuZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9ub2RlX21vZHVsZXMvc3BsaXRwYW5lcy9kaXN0L3NwbGl0cGFuZXMuZXMuanM/NGY5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIHNwbGl0cGFuZXNfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZyA9IFwiXCI7XG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQoc2NyaXB0RXhwb3J0cywgcmVuZGVyMiwgc3RhdGljUmVuZGVyRm5zMiwgZnVuY3Rpb25hbFRlbXBsYXRlLCBpbmplY3RTdHlsZXMsIHNjb3BlSWQsIG1vZHVsZUlkZW50aWZpZXIsIHNoYWRvd01vZGUpIHtcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zIDogc2NyaXB0RXhwb3J0cztcbiAgaWYgKHJlbmRlcjIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMyO1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBcImRhdGEtdi1cIiArIHNjb3BlSWQ7XG4gIH1cbiAgdmFyIGhvb2s7XG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7XG4gICAgaG9vayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQgfHwgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0O1xuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fO1xuICAgICAgfVxuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9vaztcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgKG9wdGlvbnMuZnVuY3Rpb25hbCA/IHRoaXMucGFyZW50IDogdGhpcykuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCk7XG4gICAgfSA6IGluamVjdFN0eWxlcztcbiAgfVxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2s7XG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZTtcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spIDogW2hvb2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uc1xuICB9O1xufVxuY29uc3QgX192dWUyX3NjcmlwdCQxID0ge1xuICBuYW1lOiBcInNwbGl0cGFuZXNcIixcbiAgcHJvcHM6IHtcbiAgICBob3Jpem9udGFsOiB7IHR5cGU6IEJvb2xlYW4gfSxcbiAgICBwdXNoT3RoZXJQYW5lczogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgZGJsQ2xpY2tTcGxpdHRlcjogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgcnRsOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgZmlyc3RTcGxpdHRlcjogeyB0eXBlOiBCb29sZWFuIH1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdFVwZGF0ZTogdGhpcy5yZXF1ZXN0VXBkYXRlLFxuICAgICAgb25QYW5lQWRkOiB0aGlzLm9uUGFuZUFkZCxcbiAgICAgIG9uUGFuZVJlbW92ZTogdGhpcy5vblBhbmVSZW1vdmUsXG4gICAgICBvblBhbmVDbGljazogdGhpcy5vblBhbmVDbGlja1xuICAgIH07XG4gIH0sXG4gIGRhdGE6ICgpID0+ICh7XG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIHJlYWR5OiBmYWxzZSxcbiAgICBwYW5lczogW10sXG4gICAgdG91Y2g6IHtcbiAgICAgIG1vdXNlRG93bjogZmFsc2UsXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICBhY3RpdmVTcGxpdHRlcjogbnVsbFxuICAgIH0sXG4gICAgc3BsaXR0ZXJUYXBzOiB7XG4gICAgICBzcGxpdHRlcjogbnVsbCxcbiAgICAgIHRpbWVvdXRJZDogbnVsbFxuICAgIH1cbiAgfSksXG4gIGNvbXB1dGVkOiB7XG4gICAgcGFuZXNDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhbmVzLmxlbmd0aDtcbiAgICB9LFxuICAgIGluZGV4ZWRQYW5lcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhbmVzLnJlZHVjZSgob2JqLCBwYW5lMikgPT4gKG9ialtwYW5lMi5pZF0gPSBwYW5lMikgJiYgb2JqLCB7fSk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlUGFuZUNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHBhbmUyKSA9PiB7XG4gICAgICAgIHBhbmUyLnVwZGF0ZSAmJiBwYW5lMi51cGRhdGUoe1xuICAgICAgICAgIFt0aGlzLmhvcml6b250YWwgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiXTogYCR7dGhpcy5pbmRleGVkUGFuZXNbcGFuZTIuaWRdLnNpemV9JWBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJpbmRFdmVudHMoKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICBpZiAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5iaW5kRXZlbnRzKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgaWYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uTW91c2VEb3duKGV2ZW50LCBzcGxpdHRlckluZGV4KSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMudG91Y2gubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMudG91Y2guYWN0aXZlU3BsaXR0ZXIgPSBzcGxpdHRlckluZGV4O1xuICAgIH0sXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLnRvdWNoLm1vdXNlRG93bikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnRvdWNoLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVQYW5lc1NpemUodGhpcy5nZXRDdXJyZW50TW91c2VEcmFnKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVcIiwgdGhpcy5wYW5lcy5tYXAoKHBhbmUyKSA9PiAoeyBtaW46IHBhbmUyLm1pbiwgbWF4OiBwYW5lMi5tYXgsIHNpemU6IHBhbmUyLnNpemUgfSkpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uTW91c2VVcCgpIHtcbiAgICAgIGlmICh0aGlzLnRvdWNoLmRyYWdnaW5nKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVkXCIsIHRoaXMucGFuZXMubWFwKChwYW5lMikgPT4gKHsgbWluOiBwYW5lMi5taW4sIG1heDogcGFuZTIubWF4LCBzaXplOiBwYW5lMi5zaXplIH0pKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvdWNoLm1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudG91Y2guZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSxcbiAgICBvblNwbGl0dGVyQ2xpY2soZXZlbnQsIHNwbGl0dGVySW5kZXgpIHtcbiAgICAgIGlmIChcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5kYmxDbGlja1NwbGl0dGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3BsaXR0ZXJUYXBzLnNwbGl0dGVyID09PSBzcGxpdHRlckluZGV4KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zcGxpdHRlclRhcHMudGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJUYXBzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9uU3BsaXR0ZXJEYmxDbGljayhldmVudCwgc3BsaXR0ZXJJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyVGFwcy5zcGxpdHRlciA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJUYXBzLnNwbGl0dGVyID0gc3BsaXR0ZXJJbmRleDtcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJUYXBzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnNwbGl0dGVyVGFwcy5zcGxpdHRlciA9IG51bGw7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnRvdWNoLmRyYWdnaW5nKVxuICAgICAgICB0aGlzLiRlbWl0KFwic3BsaXR0ZXItY2xpY2tcIiwgdGhpcy5wYW5lc1tzcGxpdHRlckluZGV4XSk7XG4gICAgfSxcbiAgICBvblNwbGl0dGVyRGJsQ2xpY2soZXZlbnQsIHNwbGl0dGVySW5kZXgpIHtcbiAgICAgIGxldCB0b3RhbE1pblNpemVzID0gMDtcbiAgICAgIHRoaXMucGFuZXMgPSB0aGlzLnBhbmVzLm1hcCgocGFuZTIsIGkpID0+IHtcbiAgICAgICAgcGFuZTIuc2l6ZSA9IGkgPT09IHNwbGl0dGVySW5kZXggPyBwYW5lMi5tYXggOiBwYW5lMi5taW47XG4gICAgICAgIGlmIChpICE9PSBzcGxpdHRlckluZGV4KVxuICAgICAgICAgIHRvdGFsTWluU2l6ZXMgKz0gcGFuZTIubWluO1xuICAgICAgICByZXR1cm4gcGFuZTI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGFuZXNbc3BsaXR0ZXJJbmRleF0uc2l6ZSAtPSB0b3RhbE1pblNpemVzO1xuICAgICAgdGhpcy4kZW1pdChcInBhbmUtbWF4aW1pemVcIiwgdGhpcy5wYW5lc1tzcGxpdHRlckluZGV4XSk7XG4gICAgfSxcbiAgICBvblBhbmVDbGljayhldmVudCwgcGFuZUlkKSB7XG4gICAgICB0aGlzLiRlbWl0KFwicGFuZS1jbGlja1wiLCB0aGlzLmluZGV4ZWRQYW5lc1twYW5lSWRdKTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnRNb3VzZURyYWcoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgJiYgZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgIHk6IGNsaWVudFkgLSByZWN0LnRvcFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnREcmFnUGVyY2VudGFnZShkcmFnKSB7XG4gICAgICBkcmFnID0gZHJhZ1t0aGlzLmhvcml6b250YWwgPyBcInlcIiA6IFwieFwiXTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSB0aGlzLmNvbnRhaW5lclt0aGlzLmhvcml6b250YWwgPyBcImNsaWVudEhlaWdodFwiIDogXCJjbGllbnRXaWR0aFwiXTtcbiAgICAgIGlmICh0aGlzLnJ0bCAmJiAhdGhpcy5ob3Jpem9udGFsKVxuICAgICAgICBkcmFnID0gY29udGFpbmVyU2l6ZSAtIGRyYWc7XG4gICAgICByZXR1cm4gZHJhZyAqIDEwMCAvIGNvbnRhaW5lclNpemU7XG4gICAgfSxcbiAgICBjYWxjdWxhdGVQYW5lc1NpemUoZHJhZykge1xuICAgICAgY29uc3Qgc3BsaXR0ZXJJbmRleCA9IHRoaXMudG91Y2guYWN0aXZlU3BsaXR0ZXI7XG4gICAgICBsZXQgc3VtcyA9IHtcbiAgICAgICAgcHJldlBhbmVzU2l6ZTogdGhpcy5zdW1QcmV2UGFuZXNTaXplKHNwbGl0dGVySW5kZXgpLFxuICAgICAgICBuZXh0UGFuZXNTaXplOiB0aGlzLnN1bU5leHRQYW5lc1NpemUoc3BsaXR0ZXJJbmRleCksXG4gICAgICAgIHByZXZSZWFjaGVkTWluUGFuZXM6IDAsXG4gICAgICAgIG5leHRSZWFjaGVkTWluUGFuZXM6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBtaW5EcmFnID0gMCArICh0aGlzLnB1c2hPdGhlclBhbmVzID8gMCA6IHN1bXMucHJldlBhbmVzU2l6ZSk7XG4gICAgICBjb25zdCBtYXhEcmFnID0gMTAwIC0gKHRoaXMucHVzaE90aGVyUGFuZXMgPyAwIDogc3Vtcy5uZXh0UGFuZXNTaXplKTtcbiAgICAgIGNvbnN0IGRyYWdQZXJjZW50YWdlID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5nZXRDdXJyZW50RHJhZ1BlcmNlbnRhZ2UoZHJhZyksIG1heERyYWcpLCBtaW5EcmFnKTtcbiAgICAgIGxldCBwYW5lc1RvUmVzaXplID0gW3NwbGl0dGVySW5kZXgsIHNwbGl0dGVySW5kZXggKyAxXTtcbiAgICAgIGxldCBwYW5lQmVmb3JlID0gdGhpcy5wYW5lc1twYW5lc1RvUmVzaXplWzBdXSB8fCBudWxsO1xuICAgICAgbGV0IHBhbmVBZnRlciA9IHRoaXMucGFuZXNbcGFuZXNUb1Jlc2l6ZVsxXV0gfHwgbnVsbDtcbiAgICAgIGNvbnN0IHBhbmVCZWZvcmVNYXhSZWFjaGVkID0gcGFuZUJlZm9yZS5tYXggPCAxMDAgJiYgZHJhZ1BlcmNlbnRhZ2UgPj0gcGFuZUJlZm9yZS5tYXggKyBzdW1zLnByZXZQYW5lc1NpemU7XG4gICAgICBjb25zdCBwYW5lQWZ0ZXJNYXhSZWFjaGVkID0gcGFuZUFmdGVyLm1heCA8IDEwMCAmJiBkcmFnUGVyY2VudGFnZSA8PSAxMDAgLSAocGFuZUFmdGVyLm1heCArIHRoaXMuc3VtTmV4dFBhbmVzU2l6ZShzcGxpdHRlckluZGV4ICsgMSkpO1xuICAgICAgaWYgKHBhbmVCZWZvcmVNYXhSZWFjaGVkIHx8IHBhbmVBZnRlck1heFJlYWNoZWQpIHtcbiAgICAgICAgaWYgKHBhbmVCZWZvcmVNYXhSZWFjaGVkKSB7XG4gICAgICAgICAgcGFuZUJlZm9yZS5zaXplID0gcGFuZUJlZm9yZS5tYXg7XG4gICAgICAgICAgcGFuZUFmdGVyLnNpemUgPSBNYXRoLm1heCgxMDAgLSBwYW5lQmVmb3JlLm1heCAtIHN1bXMucHJldlBhbmVzU2l6ZSAtIHN1bXMubmV4dFBhbmVzU2l6ZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFuZUJlZm9yZS5zaXplID0gTWF0aC5tYXgoMTAwIC0gcGFuZUFmdGVyLm1heCAtIHN1bXMucHJldlBhbmVzU2l6ZSAtIHRoaXMuc3VtTmV4dFBhbmVzU2l6ZShzcGxpdHRlckluZGV4ICsgMSksIDApO1xuICAgICAgICAgIHBhbmVBZnRlci5zaXplID0gcGFuZUFmdGVyLm1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wdXNoT3RoZXJQYW5lcykge1xuICAgICAgICBjb25zdCB2YXJzID0gdGhpcy5kb1B1c2hPdGhlclBhbmVzKHN1bXMsIGRyYWdQZXJjZW50YWdlKTtcbiAgICAgICAgaWYgKCF2YXJzKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgKHsgc3VtcywgcGFuZXNUb1Jlc2l6ZSB9ID0gdmFycyk7XG4gICAgICAgIHBhbmVCZWZvcmUgPSB0aGlzLnBhbmVzW3BhbmVzVG9SZXNpemVbMF1dIHx8IG51bGw7XG4gICAgICAgIHBhbmVBZnRlciA9IHRoaXMucGFuZXNbcGFuZXNUb1Jlc2l6ZVsxXV0gfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChwYW5lQmVmb3JlICE9PSBudWxsKSB7XG4gICAgICAgIHBhbmVCZWZvcmUuc2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KGRyYWdQZXJjZW50YWdlIC0gc3Vtcy5wcmV2UGFuZXNTaXplIC0gc3Vtcy5wcmV2UmVhY2hlZE1pblBhbmVzLCBwYW5lQmVmb3JlLm1pbiksIHBhbmVCZWZvcmUubWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYW5lQWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgcGFuZUFmdGVyLnNpemUgPSBNYXRoLm1pbihNYXRoLm1heCgxMDAgLSBkcmFnUGVyY2VudGFnZSAtIHN1bXMubmV4dFBhbmVzU2l6ZSAtIHN1bXMubmV4dFJlYWNoZWRNaW5QYW5lcywgcGFuZUFmdGVyLm1pbiksIHBhbmVBZnRlci5tYXgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZG9QdXNoT3RoZXJQYW5lcyhzdW1zLCBkcmFnUGVyY2VudGFnZSkge1xuICAgICAgY29uc3Qgc3BsaXR0ZXJJbmRleCA9IHRoaXMudG91Y2guYWN0aXZlU3BsaXR0ZXI7XG4gICAgICBjb25zdCBwYW5lc1RvUmVzaXplID0gW3NwbGl0dGVySW5kZXgsIHNwbGl0dGVySW5kZXggKyAxXTtcbiAgICAgIGlmIChkcmFnUGVyY2VudGFnZSA8IHN1bXMucHJldlBhbmVzU2l6ZSArIHRoaXMucGFuZXNbcGFuZXNUb1Jlc2l6ZVswXV0ubWluKSB7XG4gICAgICAgIHBhbmVzVG9SZXNpemVbMF0gPSB0aGlzLmZpbmRQcmV2RXhwYW5kZWRQYW5lKHNwbGl0dGVySW5kZXgpLmluZGV4O1xuICAgICAgICBzdW1zLnByZXZSZWFjaGVkTWluUGFuZXMgPSAwO1xuICAgICAgICBpZiAocGFuZXNUb1Jlc2l6ZVswXSA8IHNwbGl0dGVySW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHBhbmUyLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA+IHBhbmVzVG9SZXNpemVbMF0gJiYgaSA8PSBzcGxpdHRlckluZGV4KSB7XG4gICAgICAgICAgICAgIHBhbmUyLnNpemUgPSBwYW5lMi5taW47XG4gICAgICAgICAgICAgIHN1bXMucHJldlJlYWNoZWRNaW5QYW5lcyArPSBwYW5lMi5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vtcy5wcmV2UGFuZXNTaXplID0gdGhpcy5zdW1QcmV2UGFuZXNTaXplKHBhbmVzVG9SZXNpemVbMF0pO1xuICAgICAgICBpZiAocGFuZXNUb1Jlc2l6ZVswXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3Vtcy5wcmV2UmVhY2hlZE1pblBhbmVzID0gMDtcbiAgICAgICAgICB0aGlzLnBhbmVzWzBdLnNpemUgPSB0aGlzLnBhbmVzWzBdLm1pbjtcbiAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHBhbmUyLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgaSA8PSBzcGxpdHRlckluZGV4KSB7XG4gICAgICAgICAgICAgIHBhbmUyLnNpemUgPSBwYW5lMi5taW47XG4gICAgICAgICAgICAgIHN1bXMucHJldlJlYWNoZWRNaW5QYW5lcyArPSBwYW5lMi5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wYW5lc1twYW5lc1RvUmVzaXplWzFdXS5zaXplID0gMTAwIC0gc3Vtcy5wcmV2UmVhY2hlZE1pblBhbmVzIC0gdGhpcy5wYW5lc1swXS5taW4gLSBzdW1zLnByZXZQYW5lc1NpemUgLSBzdW1zLm5leHRQYW5lc1NpemU7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkcmFnUGVyY2VudGFnZSA+IDEwMCAtIHN1bXMubmV4dFBhbmVzU2l6ZSAtIHRoaXMucGFuZXNbcGFuZXNUb1Jlc2l6ZVsxXV0ubWluKSB7XG4gICAgICAgIHBhbmVzVG9SZXNpemVbMV0gPSB0aGlzLmZpbmROZXh0RXhwYW5kZWRQYW5lKHNwbGl0dGVySW5kZXgpLmluZGV4O1xuICAgICAgICBzdW1zLm5leHRSZWFjaGVkTWluUGFuZXMgPSAwO1xuICAgICAgICBpZiAocGFuZXNUb1Jlc2l6ZVsxXSA+IHNwbGl0dGVySW5kZXggKyAxKSB7XG4gICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lMiwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPiBzcGxpdHRlckluZGV4ICYmIGkgPCBwYW5lc1RvUmVzaXplWzFdKSB7XG4gICAgICAgICAgICAgIHBhbmUyLnNpemUgPSBwYW5lMi5taW47XG4gICAgICAgICAgICAgIHN1bXMubmV4dFJlYWNoZWRNaW5QYW5lcyArPSBwYW5lMi5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vtcy5uZXh0UGFuZXNTaXplID0gdGhpcy5zdW1OZXh0UGFuZXNTaXplKHBhbmVzVG9SZXNpemVbMV0gLSAxKTtcbiAgICAgICAgaWYgKHBhbmVzVG9SZXNpemVbMV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHN1bXMubmV4dFJlYWNoZWRNaW5QYW5lcyA9IDA7XG4gICAgICAgICAgdGhpcy5wYW5lc1t0aGlzLnBhbmVzQ291bnQgLSAxXS5zaXplID0gdGhpcy5wYW5lc1t0aGlzLnBhbmVzQ291bnQgLSAxXS5taW47XG4gICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lMiwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPCB0aGlzLnBhbmVzQ291bnQgLSAxICYmIGkgPj0gc3BsaXR0ZXJJbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgcGFuZTIuc2l6ZSA9IHBhbmUyLm1pbjtcbiAgICAgICAgICAgICAgc3Vtcy5uZXh0UmVhY2hlZE1pblBhbmVzICs9IHBhbmUyLm1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnBhbmVzW3BhbmVzVG9SZXNpemVbMF1dLnNpemUgPSAxMDAgLSBzdW1zLnByZXZQYW5lc1NpemUgLSBzdW1zLm5leHRSZWFjaGVkTWluUGFuZXMgLSB0aGlzLnBhbmVzW3RoaXMucGFuZXNDb3VudCAtIDFdLm1pbiAtIHN1bXMubmV4dFBhbmVzU2l6ZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VtcywgcGFuZXNUb1Jlc2l6ZSB9O1xuICAgIH0sXG4gICAgc3VtUHJldlBhbmVzU2l6ZShzcGxpdHRlckluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYW5lcy5yZWR1Y2UoKHRvdGFsLCBwYW5lMiwgaSkgPT4gdG90YWwgKyAoaSA8IHNwbGl0dGVySW5kZXggPyBwYW5lMi5zaXplIDogMCksIDApO1xuICAgIH0sXG4gICAgc3VtTmV4dFBhbmVzU2l6ZShzcGxpdHRlckluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYW5lcy5yZWR1Y2UoKHRvdGFsLCBwYW5lMiwgaSkgPT4gdG90YWwgKyAoaSA+IHNwbGl0dGVySW5kZXggKyAxID8gcGFuZTIuc2l6ZSA6IDApLCAwKTtcbiAgICB9LFxuICAgIGZpbmRQcmV2RXhwYW5kZWRQYW5lKHNwbGl0dGVySW5kZXgpIHtcbiAgICAgIGNvbnN0IHBhbmUyID0gWy4uLnRoaXMucGFuZXNdLnJldmVyc2UoKS5maW5kKChwKSA9PiBwLmluZGV4IDwgc3BsaXR0ZXJJbmRleCAmJiBwLnNpemUgPiBwLm1pbik7XG4gICAgICByZXR1cm4gcGFuZTIgfHwge307XG4gICAgfSxcbiAgICBmaW5kTmV4dEV4cGFuZGVkUGFuZShzcGxpdHRlckluZGV4KSB7XG4gICAgICBjb25zdCBwYW5lMiA9IHRoaXMucGFuZXMuZmluZCgocCkgPT4gcC5pbmRleCA+IHNwbGl0dGVySW5kZXggKyAxICYmIHAuc2l6ZSA+IHAubWluKTtcbiAgICAgIHJldHVybiBwYW5lMiB8fCB7fTtcbiAgICB9LFxuICAgIGNoZWNrU3BsaXRwYW5lc05vZGVzKCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKHRoaXMuY29udGFpbmVyLmNoaWxkcmVuKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzUGFuZSA9IGNoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcInNwbGl0cGFuZXNfX3BhbmVcIik7XG4gICAgICAgIGNvbnN0IGlzU3BsaXR0ZXIgPSBjaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJzcGxpdHBhbmVzX19zcGxpdHRlclwiKTtcbiAgICAgICAgaWYgKCFpc1BhbmUgJiYgIWlzU3BsaXR0ZXIpIHtcbiAgICAgICAgICBjaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcGxpdHBhbmVzOiBPbmx5IDxwYW5lPiBlbGVtZW50cyBhcmUgYWxsb3dlZCBhdCB0aGUgcm9vdCBvZiA8c3BsaXRwYW5lcz4uIE9uZSBvZiB5b3VyIERPTSBub2RlcyB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFkZFNwbGl0dGVyKHBhbmVJbmRleCwgbmV4dFBhbmVOb2RlLCBpc1ZlcnlGaXJzdCA9IGZhbHNlKSB7XG4gICAgICBjb25zdCBzcGxpdHRlckluZGV4ID0gcGFuZUluZGV4IC0gMTtcbiAgICAgIGNvbnN0IGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbG0uY2xhc3NMaXN0LmFkZChcInNwbGl0cGFuZXNfX3NwbGl0dGVyXCIpO1xuICAgICAgaWYgKCFpc1ZlcnlGaXJzdCkge1xuICAgICAgICBlbG0ub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHRoaXMub25Nb3VzZURvd24oZXZlbnQsIHNwbGl0dGVySW5kZXgpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdykge1xuICAgICAgICAgIGVsbS5vbnRvdWNoc3RhcnQgPSAoZXZlbnQpID0+IHRoaXMub25Nb3VzZURvd24oZXZlbnQsIHNwbGl0dGVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsbS5vbmNsaWNrID0gKGV2ZW50KSA9PiB0aGlzLm9uU3BsaXR0ZXJDbGljayhldmVudCwgc3BsaXR0ZXJJbmRleCArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGJsQ2xpY2tTcGxpdHRlcikge1xuICAgICAgICBlbG0ub25kYmxjbGljayA9IChldmVudCkgPT4gdGhpcy5vblNwbGl0dGVyRGJsQ2xpY2soZXZlbnQsIHNwbGl0dGVySW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICAgIG5leHRQYW5lTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbG0sIG5leHRQYW5lTm9kZSk7XG4gICAgfSxcbiAgICByZW1vdmVTcGxpdHRlcihub2RlKSB7XG4gICAgICBub2RlLm9ubW91c2Vkb3duID0gdm9pZCAwO1xuICAgICAgbm9kZS5vbmNsaWNrID0gdm9pZCAwO1xuICAgICAgbm9kZS5vbmRibGNsaWNrID0gdm9pZCAwO1xuICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH0sXG4gICAgcmVkb1NwbGl0dGVycygpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbSh0aGlzLmNvbnRhaW5lci5jaGlsZHJlbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwuY2xhc3NOYW1lLmluY2x1ZGVzKFwic3BsaXRwYW5lc19fc3BsaXR0ZXJcIikpXG4gICAgICAgICAgdGhpcy5yZW1vdmVTcGxpdHRlcihlbCk7XG4gICAgICB9KTtcbiAgICAgIGxldCBwYW5lSW5kZXggPSAwO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTmFtZS5pbmNsdWRlcyhcInNwbGl0cGFuZXNfX3BhbmVcIikpIHtcbiAgICAgICAgICBpZiAoIXBhbmVJbmRleCAmJiB0aGlzLmZpcnN0U3BsaXR0ZXIpXG4gICAgICAgICAgICB0aGlzLmFkZFNwbGl0dGVyKHBhbmVJbmRleCwgZWwsIHRydWUpO1xuICAgICAgICAgIGVsc2UgaWYgKHBhbmVJbmRleClcbiAgICAgICAgICAgIHRoaXMuYWRkU3BsaXR0ZXIocGFuZUluZGV4LCBlbCk7XG4gICAgICAgICAgcGFuZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVxdWVzdFVwZGF0ZShfYSkge1xuICAgICAgdmFyIF9iID0gX2EsIHsgdGFyZ2V0IH0gPSBfYiwgYXJncyA9IF9fb2JqUmVzdChfYiwgW1widGFyZ2V0XCJdKTtcbiAgICAgIGNvbnN0IHBhbmUyID0gdGhpcy5pbmRleGVkUGFuZXNbdGFyZ2V0Ll91aWRdO1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJncykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiBwYW5lMltrZXldID0gdmFsdWUpO1xuICAgIH0sXG4gICAgb25QYW5lQWRkKHBhbmUyKSB7XG4gICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgIEFycmF5LmZyb20ocGFuZTIuJGVsLnBhcmVudE5vZGUuY2hpbGRyZW4pLnNvbWUoKGVsKSA9PiB7XG4gICAgICAgIGlmIChlbC5jbGFzc05hbWUuaW5jbHVkZXMoXCJzcGxpdHBhbmVzX19wYW5lXCIpKVxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIHJldHVybiBlbCA9PT0gcGFuZTIuJGVsO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtaW4gPSBwYXJzZUZsb2F0KHBhbmUyLm1pblNpemUpO1xuICAgICAgY29uc3QgbWF4ID0gcGFyc2VGbG9hdChwYW5lMi5tYXhTaXplKTtcbiAgICAgIHRoaXMucGFuZXMuc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgIGlkOiBwYW5lMi5fdWlkLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbWluOiBpc05hTihtaW4pID8gMCA6IG1pbixcbiAgICAgICAgbWF4OiBpc05hTihtYXgpID8gMTAwIDogbWF4LFxuICAgICAgICBzaXplOiBwYW5lMi5zaXplID09PSBudWxsID8gbnVsbCA6IHBhcnNlRmxvYXQocGFuZTIuc2l6ZSksXG4gICAgICAgIGdpdmVuU2l6ZTogcGFuZTIuc2l6ZSxcbiAgICAgICAgdXBkYXRlOiBwYW5lMi51cGRhdGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwLCBpKSA9PiBwLmluZGV4ID0gaSk7XG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWRvU3BsaXR0ZXJzKCk7XG4gICAgICAgICAgdGhpcy5yZXNldFBhbmVTaXplcyh7IGFkZGVkUGFuZTogdGhpcy5wYW5lc1tpbmRleF0gfSk7XG4gICAgICAgICAgdGhpcy4kZW1pdChcInBhbmUtYWRkXCIsIHsgaW5kZXgsIHBhbmVzOiB0aGlzLnBhbmVzLm1hcCgocGFuZTMpID0+ICh7IG1pbjogcGFuZTMubWluLCBtYXg6IHBhbmUzLm1heCwgc2l6ZTogcGFuZTMuc2l6ZSB9KSkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25QYW5lUmVtb3ZlKHBhbmUyKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFuZXMuZmluZEluZGV4KChwKSA9PiBwLmlkID09PSBwYW5lMi5fdWlkKTtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLnBhbmVzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHAsIGkpID0+IHAuaW5kZXggPSBpKTtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWRvU3BsaXR0ZXJzKCk7XG4gICAgICAgIHRoaXMucmVzZXRQYW5lU2l6ZXMoeyByZW1vdmVkUGFuZTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVtb3ZlZCksIHsgaW5kZXggfSkgfSk7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJwYW5lLXJlbW92ZVwiLCB7IHJlbW92ZWQsIHBhbmVzOiB0aGlzLnBhbmVzLm1hcCgocGFuZTMpID0+ICh7IG1pbjogcGFuZTMubWluLCBtYXg6IHBhbmUzLm1heCwgc2l6ZTogcGFuZTMuc2l6ZSB9KSkgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlc2V0UGFuZVNpemVzKGNoYW5nZWRQYW5lcyA9IHt9KSB7XG4gICAgICBpZiAoIWNoYW5nZWRQYW5lcy5hZGRlZFBhbmUgJiYgIWNoYW5nZWRQYW5lcy5yZW1vdmVkUGFuZSlcbiAgICAgICAgdGhpcy5pbml0aWFsUGFuZXNTaXppbmcoKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMucGFuZXMuc29tZSgocGFuZTIpID0+IHBhbmUyLmdpdmVuU2l6ZSAhPT0gbnVsbCB8fCBwYW5lMi5taW4gfHwgcGFuZTIubWF4IDwgMTAwKSlcbiAgICAgICAgdGhpcy5lcXVhbGl6ZUFmdGVyQWRkT3JSZW1vdmUoY2hhbmdlZFBhbmVzKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lcXVhbGl6ZSgpO1xuICAgICAgaWYgKHRoaXMucmVhZHkpXG4gICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVkXCIsIHRoaXMucGFuZXMubWFwKChwYW5lMikgPT4gKHsgbWluOiBwYW5lMi5taW4sIG1heDogcGFuZTIubWF4LCBzaXplOiBwYW5lMi5zaXplIH0pKSk7XG4gICAgfSxcbiAgICBlcXVhbGl6ZSgpIHtcbiAgICAgIGNvbnN0IGVxdWFsU3BhY2UgPSAxMDAgLyB0aGlzLnBhbmVzQ291bnQ7XG4gICAgICBsZXQgbGVmdFRvQWxsb2NhdGUgPSAwO1xuICAgICAgbGV0IHVuZ3Jvd2FibGUgPSBbXTtcbiAgICAgIGxldCB1bnNocmlua2FibGUgPSBbXTtcbiAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTIpID0+IHtcbiAgICAgICAgcGFuZTIuc2l6ZSA9IE1hdGgubWF4KE1hdGgubWluKGVxdWFsU3BhY2UsIHBhbmUyLm1heCksIHBhbmUyLm1pbik7XG4gICAgICAgIGxlZnRUb0FsbG9jYXRlIC09IHBhbmUyLnNpemU7XG4gICAgICAgIGlmIChwYW5lMi5zaXplID49IHBhbmUyLm1heClcbiAgICAgICAgICB1bmdyb3dhYmxlLnB1c2gocGFuZTIuaWQpO1xuICAgICAgICBpZiAocGFuZTIuc2l6ZSA8PSBwYW5lMi5taW4pXG4gICAgICAgICAgdW5zaHJpbmthYmxlLnB1c2gocGFuZTIuaWQpO1xuICAgICAgfSk7XG4gICAgICBpZiAobGVmdFRvQWxsb2NhdGUgPiAwLjEpXG4gICAgICAgIHRoaXMucmVhZGp1c3RTaXplcyhsZWZ0VG9BbGxvY2F0ZSwgdW5ncm93YWJsZSwgdW5zaHJpbmthYmxlKTtcbiAgICB9LFxuICAgIGluaXRpYWxQYW5lc1NpemluZygpIHtcbiAgICAgIDEwMCAvIHRoaXMucGFuZXNDb3VudDtcbiAgICAgIGxldCBsZWZ0VG9BbGxvY2F0ZSA9IDEwMDtcbiAgICAgIGxldCB1bmdyb3dhYmxlID0gW107XG4gICAgICBsZXQgdW5zaHJpbmthYmxlID0gW107XG4gICAgICBsZXQgZGVmaW5lZFNpemVzID0gMDtcbiAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTIpID0+IHtcbiAgICAgICAgbGVmdFRvQWxsb2NhdGUgLT0gcGFuZTIuc2l6ZTtcbiAgICAgICAgaWYgKHBhbmUyLnNpemUgIT09IG51bGwpXG4gICAgICAgICAgZGVmaW5lZFNpemVzKys7XG4gICAgICAgIGlmIChwYW5lMi5zaXplID49IHBhbmUyLm1heClcbiAgICAgICAgICB1bmdyb3dhYmxlLnB1c2gocGFuZTIuaWQpO1xuICAgICAgICBpZiAocGFuZTIuc2l6ZSA8PSBwYW5lMi5taW4pXG4gICAgICAgICAgdW5zaHJpbmthYmxlLnB1c2gocGFuZTIuaWQpO1xuICAgICAgfSk7XG4gICAgICBsZXQgbGVmdFRvQWxsb2NhdGUyID0gMTAwO1xuICAgICAgaWYgKGxlZnRUb0FsbG9jYXRlID4gMC4xKSB7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTIpID0+IHtcbiAgICAgICAgICBpZiAocGFuZTIuc2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGFuZTIuc2l6ZSA9IE1hdGgubWF4KE1hdGgubWluKGxlZnRUb0FsbG9jYXRlIC8gKHRoaXMucGFuZXNDb3VudCAtIGRlZmluZWRTaXplcyksIHBhbmUyLm1heCksIHBhbmUyLm1pbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlZnRUb0FsbG9jYXRlMiAtPSBwYW5lMi5zaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxlZnRUb0FsbG9jYXRlMiA+IDAuMSlcbiAgICAgICAgICB0aGlzLnJlYWRqdXN0U2l6ZXMobGVmdFRvQWxsb2NhdGUsIHVuZ3Jvd2FibGUsIHVuc2hyaW5rYWJsZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlcXVhbGl6ZUFmdGVyQWRkT3JSZW1vdmUoeyBhZGRlZFBhbmUsIHJlbW92ZWRQYW5lIH0gPSB7fSkge1xuICAgICAgbGV0IGVxdWFsU3BhY2UgPSAxMDAgLyB0aGlzLnBhbmVzQ291bnQ7XG4gICAgICBsZXQgbGVmdFRvQWxsb2NhdGUgPSAwO1xuICAgICAgbGV0IHVuZ3Jvd2FibGUgPSBbXTtcbiAgICAgIGxldCB1bnNocmlua2FibGUgPSBbXTtcbiAgICAgIGlmIChhZGRlZFBhbmUgJiYgYWRkZWRQYW5lLmdpdmVuU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICBlcXVhbFNwYWNlID0gKDEwMCAtIGFkZGVkUGFuZS5naXZlblNpemUpIC8gKHRoaXMucGFuZXNDb3VudCAtIDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lMikgPT4ge1xuICAgICAgICBsZWZ0VG9BbGxvY2F0ZSAtPSBwYW5lMi5zaXplO1xuICAgICAgICBpZiAocGFuZTIuc2l6ZSA+PSBwYW5lMi5tYXgpXG4gICAgICAgICAgdW5ncm93YWJsZS5wdXNoKHBhbmUyLmlkKTtcbiAgICAgICAgaWYgKHBhbmUyLnNpemUgPD0gcGFuZTIubWluKVxuICAgICAgICAgIHVuc2hyaW5rYWJsZS5wdXNoKHBhbmUyLmlkKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKE1hdGguYWJzKGxlZnRUb0FsbG9jYXRlKSA8IDAuMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lMikgPT4ge1xuICAgICAgICBpZiAoYWRkZWRQYW5lICYmIGFkZGVkUGFuZS5naXZlblNpemUgIT09IG51bGwgJiYgYWRkZWRQYW5lLmlkID09PSBwYW5lMi5pZClcbiAgICAgICAgICA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYW5lMi5zaXplID0gTWF0aC5tYXgoTWF0aC5taW4oZXF1YWxTcGFjZSwgcGFuZTIubWF4KSwgcGFuZTIubWluKTtcbiAgICAgICAgbGVmdFRvQWxsb2NhdGUgLT0gcGFuZTIuc2l6ZTtcbiAgICAgICAgaWYgKHBhbmUyLnNpemUgPj0gcGFuZTIubWF4KVxuICAgICAgICAgIHVuZ3Jvd2FibGUucHVzaChwYW5lMi5pZCk7XG4gICAgICAgIGlmIChwYW5lMi5zaXplIDw9IHBhbmUyLm1pbilcbiAgICAgICAgICB1bnNocmlua2FibGUucHVzaChwYW5lMi5pZCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChsZWZ0VG9BbGxvY2F0ZSA+IDAuMSlcbiAgICAgICAgdGhpcy5yZWFkanVzdFNpemVzKGxlZnRUb0FsbG9jYXRlLCB1bmdyb3dhYmxlLCB1bnNocmlua2FibGUpO1xuICAgIH0sXG4gICAgcmVhZGp1c3RTaXplcyhsZWZ0VG9BbGxvY2F0ZSwgdW5ncm93YWJsZSwgdW5zaHJpbmthYmxlKSB7XG4gICAgICBsZXQgZXF1YWxTcGFjZVRvQWxsb2NhdGU7XG4gICAgICBpZiAobGVmdFRvQWxsb2NhdGUgPiAwKVxuICAgICAgICBlcXVhbFNwYWNlVG9BbGxvY2F0ZSA9IGxlZnRUb0FsbG9jYXRlIC8gKHRoaXMucGFuZXNDb3VudCAtIHVuZ3Jvd2FibGUubGVuZ3RoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZXF1YWxTcGFjZVRvQWxsb2NhdGUgPSBsZWZ0VG9BbGxvY2F0ZSAvICh0aGlzLnBhbmVzQ291bnQgLSB1bnNocmlua2FibGUubGVuZ3RoKTtcbiAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTIsIGkpID0+IHtcbiAgICAgICAgaWYgKGxlZnRUb0FsbG9jYXRlID4gMCAmJiAhdW5ncm93YWJsZS5pbmNsdWRlcyhwYW5lMi5pZCkpIHtcbiAgICAgICAgICBjb25zdCBuZXdQYW5lU2l6ZSA9IE1hdGgubWF4KE1hdGgubWluKHBhbmUyLnNpemUgKyBlcXVhbFNwYWNlVG9BbGxvY2F0ZSwgcGFuZTIubWF4KSwgcGFuZTIubWluKTtcbiAgICAgICAgICBjb25zdCBhbGxvY2F0ZWQgPSBuZXdQYW5lU2l6ZSAtIHBhbmUyLnNpemU7XG4gICAgICAgICAgbGVmdFRvQWxsb2NhdGUgLT0gYWxsb2NhdGVkO1xuICAgICAgICAgIHBhbmUyLnNpemUgPSBuZXdQYW5lU2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmICghdW5zaHJpbmthYmxlLmluY2x1ZGVzKHBhbmUyLmlkKSkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhbmVTaXplID0gTWF0aC5tYXgoTWF0aC5taW4ocGFuZTIuc2l6ZSArIGVxdWFsU3BhY2VUb0FsbG9jYXRlLCBwYW5lMi5tYXgpLCBwYW5lMi5taW4pO1xuICAgICAgICAgIGNvbnN0IGFsbG9jYXRlZCA9IG5ld1BhbmVTaXplIC0gcGFuZTIuc2l6ZTtcbiAgICAgICAgICBsZWZ0VG9BbGxvY2F0ZSAtPSBhbGxvY2F0ZWQ7XG4gICAgICAgICAgcGFuZTIuc2l6ZSA9IG5ld1BhbmVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHBhbmUyLnVwZGF0ZSh7XG4gICAgICAgICAgW3RoaXMuaG9yaXpvbnRhbCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJdOiBgJHt0aGlzLmluZGV4ZWRQYW5lc1twYW5lMi5pZF0uc2l6ZX0lYFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKE1hdGguYWJzKGxlZnRUb0FsbG9jYXRlKSA+IDAuMSkge1xuICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNwbGl0cGFuZXM6IENvdWxkIG5vdCByZXNpemUgcGFuZXMgY29ycmVjdGx5IGR1ZSB0byB0aGVpciBjb25zdHJhaW50cy5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgcGFuZXM6IHtcbiAgICAgIGRlZXA6IHRydWUsXG4gICAgICBpbW1lZGlhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYW5lQ29tcG9uZW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaG9yaXpvbnRhbCgpIHtcbiAgICAgIHRoaXMudXBkYXRlUGFuZUNvbXBvbmVudHMoKTtcbiAgICB9LFxuICAgIGZpcnN0U3BsaXR0ZXIoKSB7XG4gICAgICB0aGlzLnJlZG9TcGxpdHRlcnMoKTtcbiAgICB9LFxuICAgIGRibENsaWNrU3BsaXR0ZXIoZW5hYmxlKSB7XG4gICAgICBjb25zdCBzcGxpdHRlcnMgPSBbLi4udGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5zcGxpdHBhbmVzX19zcGxpdHRlclwiKV07XG4gICAgICBzcGxpdHRlcnMuZm9yRWFjaCgoc3BsaXR0ZXIsIGkpID0+IHtcbiAgICAgICAgc3BsaXR0ZXIub25kYmxjbGljayA9IGVuYWJsZSA/IChldmVudCkgPT4gdGhpcy5vblNwbGl0dGVyRGJsQ2xpY2soZXZlbnQsIGkpIDogdm9pZCAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuJHJlZnMuY29udGFpbmVyO1xuICAgIHRoaXMuY2hlY2tTcGxpdHBhbmVzTm9kZXMoKTtcbiAgICB0aGlzLnJlZG9TcGxpdHRlcnMoKTtcbiAgICB0aGlzLnJlc2V0UGFuZVNpemVzKCk7XG4gICAgdGhpcy4kZW1pdChcInJlYWR5XCIpO1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICB9LFxuICByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKFwiZGl2XCIsIHtcbiAgICAgIHJlZjogXCJjb250YWluZXJcIixcbiAgICAgIGNsYXNzOiBbXG4gICAgICAgIFwic3BsaXRwYW5lc1wiLFxuICAgICAgICBgc3BsaXRwYW5lcy0tJHt0aGlzLmhvcml6b250YWwgPyBcImhvcml6b250YWxcIiA6IFwidmVydGljYWxcIn1gLFxuICAgICAgICB7XG4gICAgICAgICAgXCJzcGxpdHBhbmVzLS1kcmFnZ2luZ1wiOiB0aGlzLnRvdWNoLmRyYWdnaW5nXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgfVxufTtcbmxldCBfX3Z1ZTJfcmVuZGVyLCBfX3Z1ZTJfc3RhdGljUmVuZGVyRm5zO1xuY29uc3QgX19jc3NNb2R1bGVzJDEgPSB7fTtcbnZhciBfX2NvbXBvbmVudF9fJDEgPSAvKiBAX19QVVJFX18gKi8gbm9ybWFsaXplQ29tcG9uZW50KF9fdnVlMl9zY3JpcHQkMSwgX192dWUyX3JlbmRlciwgX192dWUyX3N0YXRpY1JlbmRlckZucywgZmFsc2UsIF9fdnVlMl9pbmplY3RTdHlsZXMkMSwgbnVsbCwgbnVsbCwgbnVsbCk7XG5mdW5jdGlvbiBfX3Z1ZTJfaW5qZWN0U3R5bGVzJDEoY29udGV4dCkge1xuICBmb3IgKGxldCBvIGluIF9fY3NzTW9kdWxlcyQxKSB7XG4gICAgdGhpc1tvXSA9IF9fY3NzTW9kdWxlcyQxW29dO1xuICB9XG59XG52YXIgc3BsaXRwYW5lcyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF9fY29tcG9uZW50X18kMS5leHBvcnRzO1xufSgpO1xudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpcztcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50O1xuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInNwbGl0cGFuZXNfX3BhbmVcIiwgc3R5bGU6IF92bS5zdHlsZSwgb246IHsgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICByZXR1cm4gX3ZtLm9uUGFuZUNsaWNrKCRldmVudCwgX3ZtLl91aWQpO1xuICB9IH0gfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKTtcbn07XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW107XG5jb25zdCBfX3Z1ZTJfc2NyaXB0ID0ge1xuICBuYW1lOiBcInBhbmVcIixcbiAgaW5qZWN0OiBbXCJyZXF1ZXN0VXBkYXRlXCIsIFwib25QYW5lQWRkXCIsIFwib25QYW5lUmVtb3ZlXCIsIFwib25QYW5lQ2xpY2tcIl0sXG4gIHByb3BzOiB7XG4gICAgc2l6ZTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgbWluU2l6ZTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgbWF4U2l6ZTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAxMDAgfVxuICB9LFxuICBkYXRhOiAoKSA9PiAoe1xuICAgIHN0eWxlOiB7fVxuICB9KSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLm9uUGFuZUFkZCh0aGlzKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLm9uUGFuZVJlbW92ZSh0aGlzKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZShzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzaXplTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSB8fCB0aGlzLnNpemUgPT09IDAgPyBwYXJzZUZsb2F0KHRoaXMuc2l6ZSkgOiBudWxsO1xuICAgIH0sXG4gICAgbWluU2l6ZU51bWJlcigpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMubWluU2l6ZSk7XG4gICAgfSxcbiAgICBtYXhTaXplTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5tYXhTaXplKTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgc2l6ZU51bWJlcihzaXplKSB7XG4gICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoeyB0YXJnZXQ6IHRoaXMsIHNpemUgfSk7XG4gICAgfSxcbiAgICBtaW5TaXplTnVtYmVyKG1pbikge1xuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKHsgdGFyZ2V0OiB0aGlzLCBtaW4gfSk7XG4gICAgfSxcbiAgICBtYXhTaXplTnVtYmVyKG1heCkge1xuICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKHsgdGFyZ2V0OiB0aGlzLCBtYXggfSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgX19jc3NNb2R1bGVzID0ge307XG52YXIgX19jb21wb25lbnRfXyA9IC8qIEBfX1BVUkVfXyAqLyBub3JtYWxpemVDb21wb25lbnQoX192dWUyX3NjcmlwdCwgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMsIGZhbHNlLCBfX3Z1ZTJfaW5qZWN0U3R5bGVzLCBudWxsLCBudWxsLCBudWxsKTtcbmZ1bmN0aW9uIF9fdnVlMl9pbmplY3RTdHlsZXMoY29udGV4dCkge1xuICBmb3IgKGxldCBvIGluIF9fY3NzTW9kdWxlcykge1xuICAgIHRoaXNbb10gPSBfX2Nzc01vZHVsZXNbb107XG4gIH1cbn1cbnZhciBwYW5lID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX19jb21wb25lbnRfXy5leHBvcnRzO1xufSgpO1xuZXhwb3J0IHsgcGFuZSBhcyBQYW5lLCBzcGxpdHBhbmVzIGFzIFNwbGl0cGFuZXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/splitpanes/dist/splitpanes.es.js\n");

/***/ })

});